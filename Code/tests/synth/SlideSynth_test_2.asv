%Test the slide synth patch for various sliding up 1 fret over three
%seconds and down one fret over three seconds

clear all;
close all;
dbstop if error

%Synthsizer and sound parameters
slideSynthParams = SlideSynthParams();
slideSynthParams.enableCSG = true;
slideSynthParams.CSG_noiseSource = "NoisePulseTrain";
slideSynthParams.CSG_harmonicAccentuator = "HarmonicResonatorBank";
slideSynthParams.stringNoiseSource = "Pink";
slideSynthParams.useNoiseFile = false;
slideSynthParams.slideType = "Brass";
slideSynthParams.stringName = "D";
duration_sec = 3;
Fs_audio = SystemParams.audioRate;
Fs_ctrl = SystemParams.controlRate;
R = Fs_audio / Fs_ctrl;

%Slide motion parameters
startingFret = 0;
endingFret = 1;
L = generateLCurve(startingFret, endingFret, duration_sec, Fs_ctrl);

%Spectrogram analysis parameters
windowLength = 12*10^-3*Fs_audio; %12 ms window
window = hamming(windowLength);
overlap = .75*windowLength;
N = 4096;
y_upperLim_kHz = Fs_audio/2000;

% %Derived parameters
% numSamples_audio = duration_sec * Fs_audio;
% numSamples_ctrl = duration_sec * Fs_ctrl;
% n_audio = 0:numSamples_audio - 1;
% n_ctrl = 0:numSamples_ctrl - 1;

%********Test down 1 fret over three seconds********
%Derived parameters/control signal
% L = generateLCurve(startingFret, endingFret, duration_sec, Fs_ctrl);

% %Processing objects
% slideSynth = SlideSynth(slideSynthParams, L(1));
% y2 = zeros(1, numSamples_audio);
% slideSpeed2 = zeros(1, numSamples_audio);
% f_c2 = zeros(1, numSamples_audio);
% 
% %Processing loop
% slideSynth.pluck(); %Set up the string to generate noise...
% n = 1;
% for m = 1:numSamples_ctrl
%     slideSynth.consumeControlSignal(L(m))
%     for k = 1:R
%         if(mod(n, 100) == 0)
%             fprintf("n = %i/%i\n", n, numSamples_audio);
%         end
%         y2(n) = slideSynth.tick();
%         %Extract the parameters here as they don't get updated until the
%         %call to slideSynth.tick() due to interpolation
%         slideSpeed2(n) = slideSynth.contactSoundGenerator.slideSpeed_n;
%         f_c2(n) = slideSynth.contactSoundGenerator.f_c_n;
%         n = n + 1;
%     end
% end
% 
% figure;
% subplot(4, 1, 1)
% plot(n_audio, y2);
% title("Upwards bend");
% xlabel("n");
% ylabel("Amplitude");
% subplot(4, 1, 2);
% plot(n_ctrl, L);
% title("L[m]");
% xlabel("n");
% ylabel("Relative length");
% subplot(4, 1, 3);
% plot(n_audio, f_c2);
% title("f_c[n]");
% xlabel("n");
% ylabel("Hz");
% subplot(4, 1, 4);
% plot(n_audio, slideSpeed2);
% title("slideSpeed[n]");
% xlabel("n");
% ylabel("m/s");
y2 = runSlideSynthTest(slideSynthParams, L. duration_sec);

figure;
spectrogram(y2, window, overlap, N, Fs_audio, "yaxis");  
ylim([0 y_upperLim_kHz]);
title('Slow Upward Bend Spectrogram');

%********Test Down 1 Fret over three seconds********
%Swap the start/end points and start again
temp = startingFret;
startingFret = endingFret;
endingFret = temp;
L = generateLCurve(startingFret, endingFret, duration_sec, Fs_ctrl);

%Processing object initialization
slideSynth = SlideSynth(slideSynthParams, L(1));

%Output buffers
y3 = zeros(1, numSamples_audio);
slideSpeed3 = zeros(1, numSamples_audio);

%Processing loop
slideSynth.pluck();
n = 1;
for m = 1:numSamples_ctrl
    slideSynth.consumeControlSignal(L(m))
    for k = 1:R
        if(mod(n, 100) == 0)
            fprintf("n = %i/%i\n", n, numSamples_audio);
        end
        y3(n) = slideSynth.tick();
        %Extract the parameters here as they don't get updated until the
        %call to slideSynth.tick() due to interpolation
        slideSpeed3(n) = slideSynth.contactSoundGenerator.slideSpeed_n;
        n = n + 1;
    end
end

figure;
subplot(3, 1, 1);
plot(y3);
title("Downwards bend");
subplot(3, 1, 2);
plot(L);
title("L[n]");
subplot(3, 1, 3);
plot(slideSpeed3);
title("Slide Speed");

figure;
spectrogram(y3, window, overlap, N, Fs_audio, "yaxis");  
ylim([0 y_upperLim_kHz]);
title('Slow Downward Slide Spectrogram');